from collections.abc import Callable


# Пусть дана функция (оракул) f
# Со следующим интерфейсом
# def f(x):
#     return f(x), f'(x)
# Например, оракул для квадратичной фунции x^2/2
def f(x):
    return x * x / 2, x


# Требуется реализовать метод: который будет находить минимум функции на отрезке [a,b]
def optimize(function: Callable[[float], float], a: float, b: float, eps: float = 1e-8):
    pass

# Задание состоит из 2-х частей— реализовать любой алгоритм оптимизации по выбору
# Провести анализ работы алгоритма на нескольких функция, построить графики сходимости вида:
# кол-во итераций vs log(точность); время работы vs log(точность)
# Изучить, как метод будет работать на неунимодальных функций и привести примеры, подтверждающие поведение
# (например, что будет сходится в ближайший локальный минимум)


# Критерий оценки:
# 4-5 баллов — решение работает и дает правильный ответ,
# код реализации не вызывает вопрос + ipynb отчет с исследованием работы метода

# Оценка по дальнейшим результатам: будет 4-5 тестовых функций.
# На каждой будет для всех сданных решений строится распределение времени работы
# Далее по квантилям распределения: 10: 95%, 9: 85%, 8: 75%, 7: 50% — по каждому заданию независимо,
# далее среднее по всем
# Дополнительно требование на 8+ баллов: минимальное требование обогнать бейзлайн-решение
# (скрыт от вас, простая наивная реализация одного из методов с лекции)
